# 数据库知识点随记

## Mysql 引擎 InnoDB vs MyISAM

1. InnoDB 支持事务; MyISAM 不支持事务
2. InnoDB 支持外键定义, 即表之间的约束关系; MyISAM 不支持
3. InnoDB 主键聚簇索引, 辅助索引叶结点存储主健 id 而非数据指针, 检索要访问主键的索引树; MyISAM 非聚集索引, 索引文件保存数据指针和数据文件分离, 主索引和辅助索引没有本质差别, 查找时从索引找到数据文件指针, 再到数据文件查找数据, 故 MyISAM 可无主键
4. InnoDB 不保存文件行数; MyISAM 保存文件行数
5. InnoDB 支持行锁; MyISAM 最小粒度也是表锁
6. InnoDB 5.6 开始支持全文检索; MyISAM 很早就支持
7. InnoDB 崩溃保障机制保障崩溃后安全恢复数据; MyISAM 崩溃数据丢失
8. InnoDB 默认所有表数据保存在一个文件, 数据文件也是索引文件; MyISAM 每个表一个数据文件.myd, 一个定义文件.frm, 一个索引文件.myi
9. `delete from table` InnoDB 逐行删除, 故应用 `truncate table`; MyISAM 重建表

## B-Tree & B+Tree

* [B-Tree](/algorithm/search?id=b-tree)
* [B+Tree](/algorithm/search?id=btree)

## HASH索引

1. Hash索引仅仅能满足 =, !=, in查询, 不支持范围查询, 因为Hash算法处理后的Hash值会破坏原数据的大小关系
2. Hash索引无法进行排序操作
3. Hash索引的组合索引是合并后计算新的Hash值, 故不支持组合索引的部分索引查询
4. Hash索引生成的Hash值可能重复不唯一, 遇到大量Hash值相等的情况下，影响性能
5. Hash索引同样因为重复Hash值原因, 无法避免表的扫描,当有重复时需要先找到键位置，后依次扫描链接直到找到数据, 即使获取满足某Hash键值的数据条数，也要回表查询统计
6. Hash索引在 MySQL中, HEAP/MEMORY 引擎支持


## 聚簇索引(clustered index), 即聚集索引、聚类索引、簇集索引

1. 实际数据保存在叶子结点, 聚簇索引将索引和数据行保存在同一个B-Tree中, 查询通过聚簇索引可以直接获取数据
2. 一个表只能包含一个聚簇索引, 因为聚簇索引排序顺序决定了记录的存储顺序, 因为数据物理相邻, 故针对该索引的范围查找会比较高效, 但包含经常修改的列会频繁移动数据
3. 如果表设置了主键, 则主键就是聚簇索引, 如果表没有主键, 则会默认第一个 `not null`的`unique`作为聚簇索引, 则会默认创建一个隐藏的row_id作为聚簇索引
4. 因为 InnoDB 主键为聚簇索引, 故使用非自增主键时会导致存储数据的移动和分页操作, 同时产生碎片, 需要(OPTIMIZE TABLE)维护, 故应该避免随机或无顺序的主键
5. 聚簇索引可以是组合索引, 包含多个列
6. 聚簇索引之上创建的索引称之为辅助索引, 辅助索引访问数据总是需要二次查找, 非聚簇索引都是辅助索引(二级索引), 像复合索引、前缀索引、唯一索引, 辅助索引叶子结点存储的不再是行的物理位置, 而是主键值, 查找时需要在二级索引中找到相应叶结点, 获得行的主键值, 然后使用主键去回表查询, 这需要两次B-Tree查找

## SELECT COUNT(?)

1. 统计行数只建议使用`count(*)`, 不建议使用其他
2. `count(1)`并非是指统计第一列
3. `count(*)`与`count(1)`查询结果一样, 包含 null 行, 当MySQL确认括号内的表达式值不可能为空时, 实际是统计行数。`count(*)`的通配符*并不扩展成所有的列, 实际上他会忽略所有列而直接统计所有的行数
4. `count(culumn)` 针对指定列进行统计, 不包含 null 值
5. InnoDB 执行`select count(*)`会遍历最小可用二级索引(辅助索引), 强制指定了索引情况例外, 如果没有二级索引, 则会扫描聚簇索引, 故添加二级索引会优化 count 操作
6. InnoDB 同等对待 `count(1)` 与 `count(*)`, 故效率也一样
7. MyISAM 表第一列定义为`not null` 则不加限定条件的 `count(1)`与`select count(*) from table`有同样的效率
8. InnoDB 为事务性存储引擎, 多个事务也同时影响表行数, 所以存储行数会造成困难引发问题, 而`select count(*)`语句返回的是当前事务下可见的表行数